diff -up libxcb-1.9.1/src/xcbext.h.64bit-seqno libxcb-1.9.1/src/xcbext.h
--- libxcb-1.9.1/src/xcbext.h.64bit-seqno	2013-05-30 17:38:01.000000000 +0200
+++ libxcb-1.9.1/src/xcbext.h	2015-05-11 11:46:32.437979132 +0200
@@ -59,6 +59,30 @@ enum xcb_send_request_flags_t {
 
 unsigned int xcb_send_request(xcb_connection_t *c, int flags, struct iovec *vector, const xcb_protocol_request_t *request);
 
+/**
+ * @brief Send a request to the server, with 64-bit sequence number returned.
+ * @param c: The connection to the X server.
+ * @param flags: A combination of flags from the xcb_send_request_flags_t enumeration.
+ * @param vector: Data to send; must have two iovecs before start for internal use.
+ * @param request: Information about the request to be sent.
+ * @return The request's sequence number on success, 0 otherwise.
+ *
+ * This function sends a new request to the X server. The data of the request is
+ * given as an array of @c iovecs in the @p vector argument. The length of that
+ * array and the neccessary management information are given in the @p request
+ * argument.
+ *
+ * When this function returns, the request might or might not be sent already.
+ * Use xcb_flush() to make sure that it really was sent.
+ *
+ * Please note that this function is not the prefered way for sending requests.
+ * It's better to use the generated wrapper functions.
+ *
+ * Please note that xcb might use index -1 and -2 of the @p vector array internally,
+ * so they must be valid!
+ */
+uint64_t xcb_send_request64(xcb_connection_t *c, int flags, struct iovec *vector, const xcb_protocol_request_t *request);
+
 /* xcb_take_socket allows external code to ask XCB for permission to
  * take over the write side of the socket and send raw data with
  * xcb_writev. xcb_take_socket provides the sequence number of the last
@@ -87,8 +111,38 @@ int xcb_writev(xcb_connection_t *c, stru
 /* xcb_in.c */
 
 void *xcb_wait_for_reply(xcb_connection_t *c, unsigned int request, xcb_generic_error_t **e);
+
+/**
+ * @brief Wait for the reply of a given request, with 64-bit sequence number
+ * @param c: The connection to the X server.
+ * @param request: 64-bit sequence number of the request as returned by xcb_send_request64().
+ * @param e: Location to store errors in, or NULL. Ignored for unchecked requests.
+ *
+ * Returns the reply to the given request or returns null in the event of
+ * errors. Blocks until the reply or error for the request arrives, or an I/O
+ * error occurs.
+ *
+ * Unlike its xcb_wait_for_reply() counterpart, the given sequence number is not
+ * automatically "widened" to 64-bit.
+ */
+void *xcb_wait_for_reply64(xcb_connection_t *c, uint64_t request, xcb_generic_error_t **e);
+
 int xcb_poll_for_reply(xcb_connection_t *c, unsigned int request, void **reply, xcb_generic_error_t **error);
 
+/**
+ * @brief Poll for the reply of a given request, with 64-bit sequence number.
+ * @param c: The connection to the X server.
+ * @param request: 64-bit sequence number of the request as returned by xcb_send_request().
+ * @param reply: Location to store the reply in, must not be NULL.
+ * @param e: Location to store errors in, or NULL. Ignored for unchecked requests.
+ * @return 1 when the reply to the request was returned, else 0.
+ *
+ * Checks if the reply to the given request already received. Does not block.
+ *
+ * Unlike its xcb_poll_for_reply() counterpart, the given sequence number is not
+ * automatically "widened" to 64-bit.
+ */
+int xcb_poll_for_reply64(xcb_connection_t *c, uint64_t request, void **reply, xcb_generic_error_t **error);
 
 /* xcb_util.c */
 
diff -up libxcb-1.9.1/src/xcb.h.64bit-seqno libxcb-1.9.1/src/xcb.h
--- libxcb-1.9.1/src/xcb.h.64bit-seqno	2013-05-30 17:38:01.000000000 +0200
+++ libxcb-1.9.1/src/xcb.h	2015-05-11 11:15:09.843770532 +0200
@@ -339,6 +339,26 @@ xcb_generic_error_t *xcb_request_check(x
  */
 void xcb_discard_reply(xcb_connection_t *c, unsigned int sequence);
 
+/**
+ * @brief Discards the reply for a request, given by a 64bit sequence number
+ * @param c: The connection to the X server.
+ * @param sequence: 64-bit sequence number as returned by xcb_send_request64().
+ *
+ * Discards the reply for a request. Additionally, any error generated
+ * by the request is also discarded (unless it was an _unchecked request
+ * and the error has already arrived).
+ *
+ * This function will not block even if the reply is not yet available.
+ *
+ * Note that the sequence really does have to come from xcb_send_request64();
+ * the cookie sequence number is defined as "unsigned" int and therefore
+ * not 64-bit on all platforms.
+ * This function is not designed to operate on socket-handoff replies.
+ *
+ * Unlike its xcb_discard_reply() counterpart, the given sequence number is not
+ * automatically "widened" to 64-bit.
+ */
+void xcb_discard_reply64(xcb_connection_t *c, uint64_t sequence);
 
 /* xcb_ext.c */
 
diff -up libxcb-1.9.1/src/xcb_in.c.64bit-seqno libxcb-1.9.1/src/xcb_in.c
--- libxcb-1.9.1/src/xcb_in.c.64bit-seqno	2013-05-30 17:38:01.000000000 +0200
+++ libxcb-1.9.1/src/xcb_in.c	2015-05-11 11:16:25.427925874 +0200
@@ -431,6 +431,20 @@ void *xcb_wait_for_reply(xcb_connection_
     return ret;
 }
 
+void *xcb_wait_for_reply64(xcb_connection_t *c, uint64_t request, xcb_generic_error_t **e)
+{
+    void *ret;
+    if(e)
+        *e = 0;
+    if(c->has_error)
+        return 0;
+
+    pthread_mutex_lock(&c->iolock);
+    ret = wait_for_reply(c, request, e);
+    pthread_mutex_unlock(&c->iolock);
+    return ret;
+}
+
 static void insert_pending_discard(xcb_connection_t *c, pending_reply **prev_next, uint64_t seq)
 {
     pending_reply *pend;
@@ -498,6 +512,20 @@ void xcb_discard_reply(xcb_connection_t 
     pthread_mutex_unlock(&c->iolock);
 }
 
+void xcb_discard_reply64(xcb_connection_t *c, uint64_t sequence)
+{
+    if(c->has_error)
+        return;
+
+    /* If an error occurred when issuing the request, fail immediately. */
+    if(!sequence)
+        return;
+
+    pthread_mutex_lock(&c->iolock);
+    discard_reply(c, sequence);
+    pthread_mutex_unlock(&c->iolock);
+}
+
 int xcb_poll_for_reply(xcb_connection_t *c, unsigned int request, void **reply, xcb_generic_error_t **error)
 {
     int ret;
@@ -515,6 +543,23 @@ int xcb_poll_for_reply(xcb_connection_t 
     return ret;
 }
 
+int xcb_poll_for_reply64(xcb_connection_t *c, uint64_t request, void **reply, xcb_generic_error_t **error)
+{
+    int ret;
+    if(c->has_error)
+    {
+        *reply = 0;
+        if(error)
+            *error = 0;
+        return 1; /* would not block */
+    }
+    assert(reply != 0);
+    pthread_mutex_lock(&c->iolock);
+    ret = poll_for_reply(c, request, reply, error);
+    pthread_mutex_unlock(&c->iolock);
+    return ret;
+}
+
 xcb_generic_event_t *xcb_wait_for_event(xcb_connection_t *c)
 {
     xcb_generic_event_t *ret;
diff -up libxcb-1.9.1/src/xcb_out.c.64bit-seqno libxcb-1.9.1/src/xcb_out.c
--- libxcb-1.9.1/src/xcb_out.c.64bit-seqno	2013-05-30 17:38:01.000000000 +0200
+++ libxcb-1.9.1/src/xcb_out.c	2015-05-11 11:17:08.414966494 +0200
@@ -150,7 +150,7 @@ uint32_t xcb_get_maximum_request_length(
     return c->out.maximum_request_length.value;
 }
 
-unsigned int xcb_send_request(xcb_connection_t *c, int flags, struct iovec *vector, const xcb_protocol_request_t *req)
+uint64_t xcb_send_request64(xcb_connection_t *c, int flags, struct iovec *vector, const xcb_protocol_request_t *req)
 {
     uint64_t request;
     uint32_t prefix[2];
@@ -260,6 +260,12 @@ unsigned int xcb_send_request(xcb_connec
     return request;
 }
 
+/* request number are actually uint64_t internally but keep API compat with unsigned int */
+unsigned int xcb_send_request(xcb_connection_t *c, int flags, struct iovec *vector, const xcb_protocol_request_t *req)
+{
+    return xcb_send_request64(c, flags, vector, req);
+}
+
 int xcb_take_socket(xcb_connection_t *c, void (*return_socket)(void *closure), void *closure, int flags, uint64_t *sent)
 {
     int ret;
